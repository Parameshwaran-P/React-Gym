{
  "id": "react-030-performance",
  "title": "React Performance Optimization",
  "description": "Improve React app speed by reducing unnecessary renders",
  "duration": 10,
  "difficulty": "intermediate",
  "tags": ["react", "performance", "optimization"],
  "prerequisites": ["react-029-zustand"],
  "unlocks": ["react-031-testing"],
  "xp": 160,

  "steps": {
    "intro": {
      "type": "game-intro",
      "title": "Make React Faster",
      "story": "Your app works, but it feels slow. Time to optimize.",
      "preview": "Learn how React re-renders and how to control it."
    },

    "concept": {
      "type": "markdown",
      "title": "Why Performance Matters",
      "content": "Poor performance causes:\n- Slow UI\n- Laggy interactions\n- Bad user experience\n\nPerformance optimization focuses on avoiding unnecessary re-renders."
    },

    "concept2": {
      "type": "markdown",
      "title": "Common Causes of Re-renders",
      "content": "- State changes at wrong place\n- Passing new functions as props\n- Large component trees\n- Expensive calculations"
    },

    "syntax": {
      "type": "markdown",
      "title": "React.memo",
      "content": "```\nconst Component = React.memo(function Component(props) {\n  return <div>{props.value}</div>;\n});\n```\n\nPrevents re-render if props do not change."
    },

    "positive": {
      "type": "interactive-code",
      "title": "Without memo",
      "description": "Child re-renders every time.",
      "code": "function Child({ value }) {\n  console.log('Rendered');\n  return <p>{value}</p>;\n}\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <Child value=\"Hello\" />\n      <button onClick={() => setCount(count + 1)}>Add</button>\n    </div>\n  );\n}",
      "showPreview": false,
      "explanation": "Child renders even though props stay same."
    },

    "positive2": {
      "type": "interactive-code",
      "title": "With React.memo",
      "description": "Child renders only when props change.",
      "code": "const Child = React.memo(function Child({ value }) {\n  console.log('Rendered');\n  return <p>{value}</p>;\n});\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <Child value=\"Hello\" />\n      <button onClick={() => setCount(count + 1)}>Add</button>\n    </div>\n  );\n}",
      "showPreview": false,
      "explanation": "memo skips unnecessary re-render."
    },

    "concept3": {
      "type": "markdown",
      "title": "useCallback",
      "content": "Functions are recreated on every render.\n\nuseCallback memorizes function reference.\n\n```\nconst handleClick = useCallback(() => {\n  setCount(c => c + 1);\n}, []);\n```"
    },

    "concept4": {
      "type": "markdown",
      "title": "useMemo",
      "content": "useMemo memorizes expensive calculations.\n\n```\nconst result = useMemo(() => heavyCalculation(data), [data]);\n```"
    },

    "concept5": {
      "type": "markdown",
      "title": "Lazy Loading",
      "content": "Load components only when needed.\n\n```\nconst Dashboard = React.lazy(() => import('./Dashboard'));\n```"
    },

    "negative": {
      "type": "debug-quiz",
      "title": "Performance Bug",
      "description": "Component re-renders too often.",
      "code": "const handler = () => setCount(count + 1);",
      "question": "What is the issue?",
      "options": [
        {
          "id": "a",
          "text": "New function created every render",
          "isCorrect": true,
          "explanation": "Use useCallback to memoize function."
        },
        {
          "id": "b",
          "text": "Arrow function not allowed",
          "isCorrect": false,
          "explanation": "Arrow functions are valid."
        }
      ],
      "lesson": "Stable references improve performance."
    },

    "task": {
      "type": "coding-task",
      "title": "Optimize List",
      "description": "Prevent unnecessary list re-renders.",
      "requirements": [
        "Use React.memo",
        "Use useCallback",
        "Avoid inline functions"
      ],
      "starterCode": "function ListItem({ item }) {\n  return <li>{item}</li>;\n}",
      "solution": "Wrap ListItem with React.memo and memoize handlers.",
      "hints": [
        "Memoize child",
        "Memoize functions"
      ]
    },

    "challenge": {
      "type": "coding-challenge",
      "title": "Performance Audit",
      "description": "Optimize a slow component.",
      "requirements": [
        "Remove unnecessary state",
        "Use memoization",
        "Apply lazy loading"
      ],
      "solution": "Use memo, useCallback, and React.lazy correctly."
    },

    "memory": {
      "type": "memory-game",
      "title": "Performance Memory",
      "pairs": [
        { "concept": "React.memo", "code": "Skip re-render" },
        { "concept": "useCallback", "code": "Memoize function" },
        { "concept": "useMemo", "code": "Memoize value" },
        { "concept": "Lazy loading", "code": "Load on demand" }
      ]
    },

    "tower": {
      "type": "tower-defense",
      "concepts": [
        {
          "question": "Which hook memoizes value?",
          "options": ["useState", "useEffect", "useMemo", "useRef"],
          "correct": 2
        },
        {
          "question": "Best way to avoid child re-render?",
          "options": ["useEffect", "React.memo", "useState", "useRef"],
          "correct": 1
        }
      ],
      "waves": 3
    }
  }
}
