{
  "id": "react-030-performance",
  "title": "React Performance Optimization",
  "description": "Learn how to make React applications faster by avoiding unnecessary re-renders and heavy computations",
  "duration": 12,
  "difficulty": "advanced",
  "tags": ["react", "performance", "optimization"],
  "prerequisites": ["react-019-memoization", "react-020-react-memo", "react-021-refs"],
  "unlocks": ["react-031-testing"],
  "xp": 150,

  "steps": {
    "intro": {
      "type": "game-intro",
      "title": "Why Is My App Slow?",
      "story": "Your app works, but users complain it feels slow and laggy.",
      "preview": "Learn how to make React apps smooth and fast."
    },

    "refresher": {
      "type": "markdown",
      "title": "Real-Life Example",
      "content": "# School Classroom\n\nEvery time one student moves, the whole class stands up\n\nThat wastes energy\n\n---\n\nUnnecessary re-renders waste performance."
    },

    "concept": {
      "type": "markdown",
      "title": "What Is Performance in React?",
      "content": "Performance means:\n- Faster rendering\n- Fewer re-renders\n- Smooth UI\n- Better user experience"
    },

    "concept2": {
      "type": "markdown",
      "title": "Why Performance Issues Happen",
      "content": "Common reasons:\n- Unnecessary re-renders\n- Heavy calculations inside components\n- Large lists without optimization\n- Inline functions and objects"
    },

    "concept3": {
      "type": "markdown",
      "title": "Understanding Re-renders",
      "content": "A component re-renders when:\n- State changes\n- Props change\n- Parent re-renders\n\nNot all re-renders are bad, but unnecessary ones are."
    },

    "syntax": {
      "type": "markdown",
      "title": "useMemo Example",
      "content": "```\nconst result = useMemo(() => heavyCalculation(value), [value]);\n```"
    },

    "positive": {
      "type": "interactive-code",
      "title": "Optimizing Expensive Calculation",
      "description": "Prevent recalculating heavy logic.",
      "code": "import { useState, useMemo } from 'react';\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const expensive = useMemo(() => {\n    let total = 0;\n    for (let i = 0; i < 1000000; i++) {\n      total += i;\n    }\n    return total;\n  }, []);\n\n  return (\n    <div>\n      <p>{expensive}</p>\n      <button onClick={() => setCount(count + 1)}>Click {count}</button>\n    </div>\n  );\n}\n\nexport default App;",
      "showPreview": true,
      "explanation": "Heavy calculation runs only once."
    },

    "concept4": {
      "type": "markdown",
      "title": "React.memo",
      "content": "React.memo prevents child re-renders when props do not change."
    },

    "positive2": {
      "type": "interactive-code",
      "title": "Optimizing Child Component",
      "description": "Avoid unnecessary child re-renders.",
      "code": "import React from 'react';\n\nconst Child = React.memo(({ value }) => {\n  return <p>{value}</p>;\n});\n\nexport default Child;",
      "showPreview": false,
      "explanation": "Child re-renders only when props change."
    },

    "negative": {
      "type": "debug-quiz",
      "title": "Performance Bug",
      "description": "App feels slow.",
      "code": "items.map(item => <Item key={Math.random()} />);",
      "question": "What is the issue?",
      "options": [
        {
          "id": "a",
          "text": "Unstable keys",
          "isCorrect": true,
          "explanation": "Random keys force re-renders."
        },
        {
          "id": "b",
          "text": "React is slow",
          "isCorrect": false,
          "explanation": "React is efficient when used correctly."
        }
      ],
      "lesson": "Keys must be stable and unique."
    },

    "task": {
      "type": "coding-task",
      "title": "Optimize a List",
      "description": "Improve rendering of a large list.",
      "requirements": [
        "Use proper keys",
        "Use React.memo",
        "Avoid inline functions"
      ],
      "starterCode": "function List() {\n  return null;\n}\n\nexport default List;",
      "solution": "const Item = React.memo(({ value }) => <li>{value}</li>);\n\nfunction List({ items }) {\n  return (\n    <ul>\n      {items.map((item) => (\n        <Item key={item.id} value={item.name} />\n      ))}\n    </ul>\n  );\n}\n\nexport default List;"
    },

    "challenge": {
      "type": "coding-challenge",
      "title": "Dashboard Optimization",
      "description": "Optimize dashboard widgets.",
      "requirements": [
        "Prevent unnecessary re-renders",
        "Use memoization",
        "Split components logically"
      ],
      "solution": "Use React.memo, useMemo, and component separation to reduce re-renders."
    },

    "memory": {
      "type": "memory-game",
      "title": "Performance Memory",
      "pairs": [
        { "concept": "useMemo", "code": "cache value" },
        { "concept": "useCallback", "code": "cache function" },
        { "concept": "React.memo", "code": "memoize component" },
        { "concept": "keys", "code": "stable identity" }
      ]
    },

    "tower": {
      "type": "tower-defense",
      "concepts": [
        {
          "question": "Best way to reduce re-renders?",
          "options": ["random keys", "memoization", "more state", "inline functions"],
          "correct": 1
        },
        {
          "question": "When to optimize?",
          "options": ["always", "never", "after problem", "before coding"],
          "correct": 2
        }
      ],
      "waves": 3
    }
  }
}
