{
  "id": "react-007-usereducer",
  "title": "useReducer Hook",
  "description": "Manage complex state logic in React using useReducer",
  "duration": 12,
  "difficulty": "intermediate",
  "tags": ["hooks", "state-management", "useReducer"],
  "prerequisites": ["react-006-usestate"],
  "unlocks": ["react-008-custom-hooks"],
  "xp": 80,
   "preview": {
    "videoUrl": "/public/input.mp4", 
    "platform": "direct",
    "thumbnail": "/thumbnails/custom-hooks.jpg",
    "duration": "10:15"
  },
  "steps": {
    "refresher": {
      "type": "markdown",
      "title": "üè• Real-Life Story: Hospital Patient Management",
      "content": "# üè• Patient Management System\n\nA hospital tracks patients and their statuses. The front desk can:\n\n- Admit new patients\n- Update patient status (Stable, Critical, Discharged)\n- Discharge patients\n\n‚ùå Problem: Using multiple useState hooks for each action becomes messy and error-prone.\n\n---\n\n## üß† Why This Happens\n\n- Each action changes multiple state variables\n- Logic spreads across multiple handlers\n- Difficult to maintain or scale\n\n---\n\n## ‚úÖ React Solution: useReducer\n\n`useReducer` allows you to:\n\n- Keep all state logic in a **single reducer function**\n- Define clear **actions** for updates\n- Make state predictable and maintainable\n\nThink of it as a **hospital rulebook**: every action is defined, predictable, and centralized.\n\n---\n\n## üîß Basic Pattern\n\n```js\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch(action.type) {\n    case 'increment': return { count: state.count + 1 };\n    case 'decrement': return { count: state.count - 1 };\n    default: return state;\n  }\n}\n\nconst [state, dispatch] = useReducer(reducer, initialState);\n\n// Usage:\ndispatch({ type: 'increment' });\n```"
    },
    "positive": {
      "type": "interactive-code",
      "title": "‚úÖ Positive Case: Patient State Management",
      "description": "Manage multiple patient actions in a single reducer.",
      "code": "import { useReducer } from 'react';\n\nconst initialState = [];\n\nfunction reducer(state, action) {\n  switch(action.type) {\n    case 'ADMIT':\n      return [...state, action.payload];\n    case 'UPDATE_STATUS':\n      return state.map(p => p.id === action.payload.id ? {...p, status: action.payload.status} : p);\n    case 'DISCHARGE':\n      return state.filter(p => p.id !== action.payload.id);\n    default:\n      return state;\n  }\n}\n\nfunction PatientManager() {\n  const [patients, dispatch] = useReducer(reducer, initialState);\n\n  function admitPatient() {\n    const id = Date.now();\n    dispatch({ type: 'ADMIT', payload: { id, name: 'New Patient', status: 'Stable' } });\n  }\n\n  function updateStatus(id, status) {\n    dispatch({ type: 'UPDATE_STATUS', payload: { id, status } });\n  }\n\n  function dischargePatient(id) {\n    dispatch({ type: 'DISCHARGE', payload: { id } });\n  }\n\n  return (\n    <div className=\"p-6 space-y-3\">\n      <button onClick={admitPatient} className=\"bg-green-600 text-white px-4 py-2 rounded\">Admit Patient</button>\n\n      {patients.map(p => (\n        <div key={p.id} className=\"border p-3 rounded space-x-2\">\n          <span>{p.name} - {p.status}</span>\n          <button onClick={() => updateStatus(p.id, 'Critical')} className=\"bg-red-500 text-white px-2 rounded\">Critical</button>\n          <button onClick={() => updateStatus(p.id, 'Stable')} className=\"bg-blue-500 text-white px-2 rounded\">Stable</button>\n          <button onClick={() => dischargePatient(p.id)} className=\"bg-gray-600 text-white px-2 rounded\">Discharge</button>\n        </div>\n      ))}\n    </div>\n  );\n}\n\nexport default PatientManager;",
      "showPreview": true,
      "explanation": "**How it works (Hospital Mapping):**\n\n1. `patients` state lives in the reducer\n2. Actions (`ADMIT`, `UPDATE_STATUS`, `DISCHARGE`) define all possible changes\n3. Components call `dispatch()` instead of multiple setters\n4. State updates are centralized and predictable\n\n‚úÖ **Key Rule:** Reducer = single source of truth for complex state"
    },
    "negative": {
      "type": "debug-quiz",
      "title": "üêõ Common Mistake: Multiple useState Hooks",
      "description": "Why is using multiple useState hooks for each patient action problematic?",
      "code": "const [patients, setPatients] = useState([]);\nconst [statusUpdate, setStatusUpdate] = useState('');\nconst [dischargeId, setDischargeId] = useState(null);",
      "question": "What's wrong with this approach?",
      "options": [
        {
          "id": "a",
          "text": "React does not allow multiple useState",
          "isCorrect": false,
          "explanation": "React allows multiple useState, but it becomes messy."
        },
        {
          "id": "b",
          "text": "State updates are scattered and logic is hard to maintain",
          "isCorrect": true,
          "explanation": "‚úÖ Correct! Reducer centralizes all actions."
        },
        {
          "id": "c",
          "text": "Cannot update objects in state",
          "isCorrect": false,
          "explanation": "Objects can be updated, but multiple setters make it harder."
        },
        {
          "id": "d",
          "text": "Triggers infinite renders",
          "isCorrect": false,
          "explanation": "Not necessarily; the problem is maintainability."
        }
      ],
      "correctCode": "Use a single useReducer with actions ADMIT, UPDATE_STATUS, DISCHARGE"
    },
    "task": {
      "type": "coding-task",
      "title": "üõ†Ô∏è Your Turn: Manage Patient List",
      "description": "Use useReducer to implement admit, status update, and discharge functionality.",
      "requirements": [
        "Define reducer with ADMIT, UPDATE_STATUS, DISCHARGE",
        "Dispatch actions for each button",
        "Patient list updates correctly"
      ],
      "starterCode": "import { useReducer } from 'react';\n\nconst initialState = [];\nfunction reducer(state, action) {\n  // TODO\n}\n\nfunction PatientManager() {\n  const [patients, dispatch] = useReducer(reducer, initialState);\n  // TODO: add admit, update, discharge functions\n  return <div></div>;\n}\n\nexport default PatientManager;",
      "solution": "/* Same as Positive Case Code Above */",
      "hints": [
        "Use switch-case inside reducer",
        "Dispatch actions with type and payload",
        "State must be immutable (return new arrays/objects)"
      ],
      "tests": [
        "Patient admitted shows in list",
        "Status updates correctly",
        "Patient can be discharged"
      ]
    },
    "challenge": {
      "type": "coding-challenge",
      "title": "üèÜ Challenge: Multi-Patient Dashboard",
      "description": "Combine useReducer with Context to manage multiple patients globally.",
      "requirements": [
        "Create PatientContext with Provider",
        "Reducer manages all patient actions",
        "Any component can dispatch actions",
        "Highlight critical patients"
      ],
      "starterCode": "import { createContext, useReducer } from 'react';\n\nconst PatientContext = createContext();\n\nconst initialState = [];\nfunction reducer(state, action) {\n  // TODO\n}\n\nfunction HospitalApp() {\n  const [patients, dispatch] = useReducer(reducer, initialState);\n  // TODO: Provide context\n}\n\nexport default HospitalApp;",
      "solution": "/* Combine Positive Case useReducer with Context.Provider, wrap child components */",
      "hints": [
        "Use PatientContext.Provider",
        "Children use useContext(PatientContext) to dispatch",
        "Reducer handles all logic"
      ],
      "tests": [
        "Any child can admit patient",
        "Status updates globally",
        "Critical patients highlighted"
      ]
    }
  }
}
