{
  "id": "react-020-react-memo",
  "title": "React.memo",
  "description": "Prevent unnecessary component re-renders using React.memo",
  "duration": 10,
  "difficulty": "intermediate",
  "tags": ["react", "performance", "react-memo"],
  "prerequisites": ["react-019-memoization"],
  "unlocks": ["react-021-refs"],
  "xp": 110,

  "steps": {
    "intro": {
      "type": "game-intro",
      "title": "Freeze What Doesn‚Äôt Change",
      "story": "Your component keeps re-rendering even when props stay the same.",
      "preview": "Learn how to stop useless re-renders."
    },

    "refresher": {
      "type": "markdown",
      "title": "Real-Life Example",
      "content": "# TV Remote\n\nYou change volume üîä\n\nTV screen doesn‚Äôt reload\n\nOnly volume changes\n\n---\n\nReact.memo works the same way.\n\nIf input is same ‚ûú no re-render."
    },

    "concept": {
      "type": "markdown",
      "title": "What is React.memo?",
      "content": "React.memo is a **higher-order component**.\n\nIt:\n- Remembers previous props\n- Compares new props\n- Skips re-render if props are same"
    },

    "concept2": {
      "type": "markdown",
      "title": "When Does a Component Re-render?",
      "content": "A component re-renders when:\n\n- State changes\n- Props change\n- Parent re-renders\n\nReact.memo helps with **prop-based re-renders**."
    },

    "syntax": {
      "type": "markdown",
      "title": "React.memo Syntax",
      "content": "```\nconst MyComponent = React.memo(function MyComponent(props) {\n  return <div />;\n});\n```"
    },

    "positive": {
      "type": "interactive-code",
      "title": "Problem: Unnecessary Re-render",
      "description": "Child re-renders even when props don‚Äôt change.",
      "code": "import { useState } from 'react';\n\nfunction Child({ value }) {\n  console.log('Child rendered');\n  return <p>{value}</p>;\n}\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <Child value=\"Hello\" />\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}\n\nexport default Parent;",
      "showPreview": true,
      "explanation": "Child renders again even though value didn‚Äôt change."
    },

    "positive2": {
      "type": "interactive-code",
      "title": "Solution: React.memo",
      "description": "Child renders only once.",
      "code": "import { useState, memo } from 'react';\n\nconst Child = memo(function Child({ value }) {\n  console.log('Child rendered');\n  return <p>{value}</p>;\n});\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <Child value=\"Hello\" />\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}\n\nexport default Parent;",
      "showPreview": true,
      "explanation": "Child skips re-render because props didn‚Äôt change."
    },

    "concept3": {
      "type": "markdown",
      "title": "Important Rule",
      "content": "React.memo works **only if props are same**.\n\n‚ö†Ô∏è Functions and objects are recreated every render.\n\nThat‚Äôs why React.memo is often used with:\n- useCallback\n- useMemo"
    },

    "negative": {
      "type": "debug-quiz",
      "title": "Why React.memo Failed?",
      "description": "Component still re-renders.",
      "code": "<Child onClick={() => console.log('hi')} />",
      "question": "Why memo didn‚Äôt work?",
      "options": [
        {
          "id": "a",
          "text": "Function prop is recreated",
          "isCorrect": true,
          "explanation": "New function = new prop = re-render."
        },
        {
          "id": "b",
          "text": "React.memo is broken",
          "isCorrect": false,
          "explanation": "React.memo works as expected."
        }
      ],
      "lesson": "Use useCallback for function props."
    },

    "task": {
      "type": "coding-task",
      "title": "Optimized Child Component",
      "description": "Prevent unnecessary child re-renders.",
      "requirements": [
        "React.memo",
        "Static props"
      ],
      "starterCode": "function Child({ label }) {\n  return <p>{label}</p>;\n}\n\nexport default Child;",
      "solution": "import { memo } from 'react';\n\nconst Child = memo(function Child({ label }) {\n  return <p>{label}</p>;\n});\n\nexport default Child;"
    },

    "challenge": {
      "type": "coding-challenge",
      "title": "Parent + Child Optimization",
      "description": "Fix re-render using React.memo and useCallback.",
      "requirements": [
        "React.memo",
        "useCallback",
        "Button click handler"
      ],
      "solution": "import { useState, useCallback, memo } from 'react';\n\nconst Child = memo(function Child({ onClick }) {\n  console.log('Child render');\n  return <button onClick={onClick}>Child Button</button>;\n});\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = useCallback(() => {\n    console.log('Clicked');\n  }, []);\n\n  return (\n    <div>\n      <Child onClick={handleClick} />\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}\n\nexport default Parent;"
    },

    "memory": {
      "type": "memory-game",
      "title": "React.memo Memory",
      "pairs": [
        { "concept": "React.memo", "code": "skip re-render" },
        { "concept": "props", "code": "input data" },
        { "concept": "useCallback", "code": "stable function" },
        { "concept": "performance", "code": "fewer renders" }
      ]
    },

    "tower": {
      "type": "tower-defense",
      "concepts": [
        {
          "question": "React.memo prevents?",
          "options": ["state updates", "API calls", "re-renders", "effects"],
          "correct": 2
        },
        {
          "question": "React.memo compares?",
          "options": ["state", "props", "DOM", "hooks"],
          "correct": 1
        }
      ],
      "waves": 3
    }
  }
}
