{
  "id": "react-002-useeffect",
  "title": "useEffect Hook",
  "description": "Manage side effects and lifecycle behavior in React components",
  "duration": 10,
  "difficulty": "beginner",
  "tags": ["hooks", "effects", "lifecycle"],
  "prerequisites": ["react-001-usestate"],
  "unlocks": ["react-003-usecontext"],
  "xp": 70,
  "steps": {
    "refresher": {
      "type": "markdown",
      "title": "ğŸ¥ Real-Life Story: Hospital Heart Monitor",
      "content": "# ğŸ¥ Hospital Heart Monitor\n\nImagine you're building a **heart monitoring system** in a hospital.\n\nA patient is connected to a monitor that:\n\n- Reads heart rate every few seconds\n- Displays live updates on screen\n\nEverything works fine... until this happens ğŸ‘‡\n\n---\n\n## âŒ The Problem\n\n- Patient leaves the room\n- Monitor **continues running** in the background\n- System wastes resources\n- Multiple monitors start stacking up ğŸ˜¨\n\n---\n\n## ğŸ§  Why This Happens\n\nSome actions:\n- Fetching data\n- Setting timers\n- Listening to events\n\nThese are called **side effects**.\n\nIf you donâ€™t control **when they start** and **when they stop**, problems occur.\n\n---\n\n## âœ… React Solution: useEffect\n\n`useEffect` lets you:\n\n- Run code **after render**\n- Control **when it runs**\n- Clean up when the component unmounts\n\n---\n\n## ğŸ”§ Basic Syntax\n\n```js\nuseEffect(() => {\n  // side effect logic\n\n  return () => {\n    // cleanup logic\n  };\n}, [dependencies]);\n```\n\nğŸ‘‰ **Next: Letâ€™s start the heart monitor correctly.**"
    },
    "positive": {
      "type": "interactive-code",
      "title": "âœ… Positive Case: Heart Rate Monitor",
      "description": "The monitor starts when the patient arrives and stops when they leave.",
      "code": "import { useEffect, useState } from 'react';\n\nfunction HeartMonitor() {\n  const [heartRate, setHeartRate] = useState(72);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setHeartRate((prev) => prev + Math.floor(Math.random() * 3 - 1));\n    }, 2000);\n\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, []);\n\n  return (\n    <div className=\"p-6 bg-white rounded-lg shadow\">\n      <h2 className=\"text-2xl font-bold mb-4\">â¤ï¸ Heart Monitor</h2>\n      <p className=\"text-4xl text-red-600\">{heartRate} BPM</p>\n    </div>\n  );\n}\n\nexport default HeartMonitor;",
      "showPreview": true,
      "explanation": "**How it works (Hospital Mapping):**\n\n1. Patient arrives â†’ component mounts\n2. `useEffect` starts the heart monitor\n3. Heart rate updates every 2 seconds\n4. Patient leaves â†’ component unmounts\n5. Cleanup stops the monitor\n\nâœ… **Key Rule:** Always clean up effects that run continuously."
    },
    "negative": {
      "type": "debug-quiz",
      "title": "ğŸ› Common Mistake: No Cleanup",
      "description": "The heart monitor keeps running even after the patient leaves. Why?",
      "code": "import { useEffect, useState } from 'react';\n\nfunction BrokenMonitor() {\n  const [heartRate, setHeartRate] = useState(72);\n\n  useEffect(() => {\n    setInterval(() => {\n      setHeartRate((prev) => prev + 1);\n    }, 2000);\n  }, []);\n\n  return <p>{heartRate} BPM</p>;\n}\n\nexport default BrokenMonitor;",
      "question": "Why is this code dangerous?",
      "options": [
        {
          "id": "a",
          "text": "useEffect should not be used with setInterval",
          "isCorrect": false,
          "explanation": "setInterval is fine, but it must be cleaned up."
        },
        {
          "id": "b",
          "text": "Missing cleanup causes memory leaks",
          "isCorrect": true,
          "explanation": "âœ… Correct! Without cleanup, the interval continues running even after the component unmounts."
        },
        {
          "id": "c",
          "text": "State updates are not allowed inside useEffect",
          "isCorrect": false,
          "explanation": "State updates are allowed inside effects."
        },
        {
          "id": "d",
          "text": "The dependency array is wrong",
          "isCorrect": false,
          "explanation": "The dependency array is correct, but cleanup is missing."
        }
      ],
      "correctCode": "useEffect(() => {\n  const intervalId = setInterval(() => {\n    setHeartRate((prev) => prev + 1);\n  }, 2000);\n\n  return () => clearInterval(intervalId);\n}, []);",
      "lesson": "**Real-Life Mistake:**\n\nThis is like leaving hospital machines running after the patient leaves.\n\nâŒ Wastes resources\nâŒ Causes performance issues\n\nâœ… Always stop effects when theyâ€™re no longer needed."
    },
    "task": {
      "type": "coding-task",
      "title": "ğŸ› ï¸ Your Turn: Room Temperature Monitor",
      "description": "Build a temperature monitor that updates every 3 seconds and stops when the component unmounts.",
      "requirements": [
        "Use useEffect",
        "Use setInterval",
        "Update temperature state",
        "Clean up the interval"
      ],
      "starterCode": "import { useEffect, useState } from 'react';\n\nfunction TemperatureMonitor() {\n  const [temp, setTemp] = useState(24);\n\n  // TODO: Add useEffect here\n\n  return (\n    <div className=\"p-6\">\n      <h2>ğŸŒ¡ï¸ Room Temperature</h2>\n      <p className=\"text-3xl\">{temp}Â°C</p>\n    </div>\n  );\n}\n\nexport default TemperatureMonitor;",
      "solution": "import { useEffect, useState } from 'react';\n\nfunction TemperatureMonitor() {\n  const [temp, setTemp] = useState(24);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setTemp((prev) => prev + 1);\n    }, 3000);\n\n    return () => clearInterval(id);\n  }, []);\n\n  return (\n    <div className=\"p-6\">\n      <h2>ğŸŒ¡ï¸ Room Temperature</h2>\n      <p className=\"text-3xl\">{temp}Â°C</p>\n    </div>\n  );\n}\n\nexport default TemperatureMonitor;",
      "hints": [
        "useEffect runs after render",
        "Store interval ID",
        "Return cleanup function"
      ],
      "tests": [
        "Temperature updates every 3 seconds",
        "No memory leaks",
        "Cleanup runs on unmount"
      ]
    },
    "challenge": {
      "type": "coding-challenge",
      "title": "ğŸ† Challenge: Patient Status Tracker",
      "description": "Track patient status changes and log them whenever the status updates.",
      "requirements": [
        "Use useState for patient status",
        "Use useEffect to log status changes",
        "Dependency array should track status only"
      ],
      "starterCode": "import { useEffect, useState } from 'react';\n\nfunction PatientStatus() {\n  const [status, setStatus] = useState('Stable');\n\n  // TODO: Log status changes\n\n  return (\n    <div className=\"p-6\">\n      <p>Status: {status}</p>\n      <button onClick={() => setStatus('Critical')}>Critical</button>\n      <button onClick={() => setStatus('Stable')}>Stable</button>\n    </div>\n  );\n}\n\nexport default PatientStatus;",
      "solution": "import { useEffect, useState } from 'react';\n\nfunction PatientStatus() {\n  const [status, setStatus] = useState('Stable');\n\n  useEffect(() => {\n    console.log('Patient status changed:', status);\n  }, [status]);\n\n  return (\n    <div className=\"p-6\">\n      <p>Status: {status}</p>\n      <button onClick={() => setStatus('Critical')}>Critical</button>\n      <button onClick={() => setStatus('Stable')}>Stable</button>\n    </div>\n  );\n}\n\nexport default PatientStatus;",
      "hints": [
        "Effects can depend on state",
        "Dependency array controls execution",
        "No cleanup needed for console.log"
      ],
      "tests": [
        "Effect runs on status change",
        "Does not run unnecessarily",
        "Logs correct value"
      ]
    }
  }
}
