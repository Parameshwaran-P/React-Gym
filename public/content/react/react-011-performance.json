{
  "id": "react-012-performance",
  "title": "Performance Optimization",
  "description": "Learn how to optimize React apps for speed and efficiency",
  "duration": 12,
  "difficulty": "advanced",
  "tags": ["performance", "optimization", "react", "memoization"],
  "prerequisites": ["react-010-protected"],
  "unlocks": ["react-012-testing"],
  "xp": 100,
  "steps": {
    "refresher": {
      "type": "markdown",
      "title": "üè• Real-Life Story: Hospital App Slowness",
      "content": "# ‚ö° Performance Challenges in Hospital App\n\nImagine our hospital dashboard has **hundreds of patients** and **multiple wards**:\n\n- Rendering all patients every time a status changes is slow\n- Components re-render unnecessarily\n- Doctors get frustrated waiting for updates\n\n‚ùå Problem: Unoptimized React code leads to wasted renders and laggy UI.\n\n---\n\n## üß† Why This Happens\n\n- React re-renders a component whenever its props or state change\n- Passing new object/array references causes child components to re-render\n- Expensive calculations inside render slow down the app\n\n---\n\n## ‚úÖ React Solutions\n\n1. **React.memo** - memoize functional components to prevent unnecessary re-renders\n2. **useMemo** - memoize expensive calculations\n3. **useCallback** - memoize functions passed as props\n4. **Virtualization** - render only visible items in large lists (e.g., react-window)\n\nThink of it as **hospital triage**: only update the patient info that changed, not the whole ward."
    },
    "positive": {
      "type": "interactive-code",
      "title": "‚úÖ Positive Case: Optimize Patient List",
      "description": "Use React.memo and useCallback to prevent unnecessary re-renders in patient list.",
      "code": "import { useState, useCallback, memo } from 'react';\n\nconst Patient = memo(({ patient, onUpdate }) => {\n  console.log('Rendering patient:', patient.name);\n  return (\n    <div className='border p-2 rounded flex justify-between'>\n      <span>{patient.name} - {patient.status}</span>\n      <button onClick={() => onUpdate(patient.id, 'Critical')} className='bg-red-600 text-white px-2 rounded'>Critical</button>\n    </div>\n  );\n});\n\nfunction PatientList() {\n  const [patients, setPatients] = useState([\n    { id: 1, name: 'Meena', status: 'Stable' },\n    { id: 2, name: 'Ravi', status: 'Stable' }\n  ]);\n\n  const updateStatus = useCallback((id, status) => {\n    setPatients(p => p.map(pat => pat.id === id ? {...pat, status} : pat));\n  }, []);\n\n  return (\n    <div className='space-y-2'>\n      {patients.map(p => <Patient key={p.id} patient={p} onUpdate={updateStatus} />)}\n    </div>\n  );\n}\n\nexport default PatientList;",
      "showPreview": true,
      "explanation": "**How it works:**\n\n1. `Patient` component is wrapped with `memo` ‚Üí prevents re-render if props haven't changed\n2. `updateStatus` function is memoized with `useCallback` ‚Üí preserves reference so child doesn't re-render unnecessarily\n3. Only the patient whose status changed actually updates\n\n‚úÖ **Key Rule:** Identify expensive components and functions, memoize them appropriately."
    },
    "negative": {
      "type": "debug-quiz",
      "title": "üêõ Common Mistake: Unnecessary Re-Renders",
      "description": "Why does the PatientList re-render every patient on each update?",
      "code": "function PatientList() {\n  const [patients, setPatients] = useState([...]);\n  const updateStatus = (id, status) => {\n    setPatients(p => p.map(pat => pat.id === id ? {...pat, status} : pat));\n  };\n  return patients.map(p => <Patient key={p.id} patient={p} onUpdate={updateStatus} />);\n}",
      "question": "What's causing unnecessary re-renders?",
      "options": [
        {
          "id": "a",
          "text": "React always re-renders all components by default",
          "isCorrect": false,
          "explanation": "React re-renders parent and child only if props or state change references."
        },
        {
          "id": "b",
          "text": "updateStatus is recreated on every render, causing child re-renders",
          "isCorrect": true,
          "explanation": "‚úÖ Correct! useCallback fixes this by keeping function reference stable."
        },
        {
          "id": "c",
          "text": "useState cannot handle arrays",
          "isCorrect": false,
          "explanation": "useState works fine with arrays."
        },
        {
          "id": "d",
          "text": "Patient component should not be functional",
          "isCorrect": false,
          "explanation": "Functional components are fine; wrapping with memo helps performance."
        }
      ],
      "correctCode": "Wrap Patient with React.memo and memoize updateStatus with useCallback."
    },
    "task": {
      "type": "coding-task",
      "title": "üõ†Ô∏è Your Turn: Optimize Hospital Dashboard",
      "description": "Identify expensive patient components and optimize re-renders using memoization.",
      "requirements": [
        "Wrap individual patient components with React.memo",
        "Memoize functions passed as props using useCallback",
        "Use useMemo if calculating derived data",
        "Verify console logs to ensure minimal re-renders"
      ],
      "starterCode": "import { useState } from 'react';\n\nfunction PatientList() {\n  const [patients, setPatients] = useState([...]);\n  const updateStatus = (id, status) => {/* TODO */};\n  return patients.map(p => <Patient key={p.id} patient={p} onUpdate={updateStatus} />);\n}",
      "solution": "/* Same as Positive Case Code Above */",
      "hints": [
        "Wrap child components with memo",
        "Use useCallback for functions passed to children",
        "Consider useMemo for derived arrays or calculations"
      ],
      "tests": [
        "Patient components do not re-render unnecessarily",
        "updateStatus updates only target patient",
        "Console logs confirm memoization"
      ]
    },
    "challenge": {
      "type": "coding-challenge",
      "title": "üèÜ Challenge: Large Hospital with 1000 Patients",
      "description": "Optimize a hospital dashboard with multiple wards and 1000+ patients using memoization and virtualization.",
      "requirements": [
        "Use React.memo for individual patients",
        "Memoize functions and derived calculations",
        "Render only visible patients using react-window or similar",
        "Ensure smooth scrolling and fast updates"
      ],
      "starterCode": "/* Use React.memo, useCallback, useMemo and virtualization */",
      "solution": "/* Combine memoization and react-window for performant rendering */",
      "hints": [
        "Virtualize long lists with react-window",
        "Avoid creating new functions in render",
        "Use memoization for derived data like filtered or sorted patients"
      ],
      "tests": [
        "Smooth rendering with 1000+ patients",
        "Updating a patient only re-renders that patient",
        "Scrolling does not lag"
      ]
    }
  }
}
