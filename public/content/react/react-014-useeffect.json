{
  "id": "react-014-useeffect",
  "title": "useEffect Hook",
  "description": "Run side effects in React like API calls, timers, and subscriptions",
  "duration": 9,
  "difficulty": "beginner",
  "tags": ["react", "hooks", "lifecycle", "side-effects"],
  "prerequisites": ["react-013-lifting-state"],
  "unlocks": ["react-015-data-fetching"],
  "xp": 100,

  "steps": {
    "intro": {
      "type": "game-intro",
      "title": "‚è∞ Effect City",
      "story": "Your app needs to do work AFTER screen updates.",
      "preview": "Learn how React reacts to changes."
    },

    "story": {
      "type": "markdown",
      "title": "Real Life Story: Alarm Clock",
      "content": "You wake up.\n\nAfter waking:\n‚Ä¢ Alarm rings\n‚Ä¢ You check time\n‚Ä¢ You turn it off\n\nAlarm doesn't ring while sleeping.\n\nüëâ **Actions happen AFTER something changes.**"
    },

    "concept": {
      "type": "markdown",
      "title": "What is useEffect?",
      "content": "`useEffect` lets you run code **after render**.\n\nUsed for:\n‚Ä¢ API calls\n‚Ä¢ Timers\n‚Ä¢ Event listeners\n‚Ä¢ DOM updates\n\nThink of it as:\n> \"When this changes, do this.\""
    },

    "syntax": {
      "type": "markdown",
      "title": "Basic Syntax",
      "content": "```js\nuseEffect(() => {\n  // side effect\n}, [dependencies]);\n```\n\n‚Ä¢ Runs after render\n‚Ä¢ Dependency controls WHEN"
    },

    "positive": {
      "type": "interactive-code",
      "title": "Correct Example: Page Title",
      "description": "Update browser tab when count changes.",
      "code": "import { useState, useEffect } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `Count: ${count}`;\n  }, [count]);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}\n\nexport default Counter;",
      "showPreview": true,
      "explanation": "When count changes ‚Üí effect runs ‚Üí title updates."
    },

    "negative": {
      "type": "debug-quiz",
      "title": "üêõ Infinite Loop Bug",
      "description": "Why is this dangerous?",
      "code": "useEffect(() => {\n  setCount(count + 1);\n});",
      "question": "What is the issue?",
      "options": [
        {
          "id": "a",
          "text": "useEffect runs forever",
          "isCorrect": true,
          "explanation": "Correct. State update causes re-render ‚Üí effect runs again."
        },
        {
          "id": "b",
          "text": "setCount is invalid",
          "isCorrect": false,
          "explanation": "setCount is valid but used incorrectly."
        }
      ],
      "lesson": "Always control effects with dependencies."
    },

    "dependency": {
      "type": "markdown",
      "title": "Dependency Types",
      "content": "```js\nuseEffect(() => {}, [])\n```\nRuns once (on mount)\n\n```js\nuseEffect(() => {}, [count])\n```\nRuns when count changes\n\n```js\nuseEffect(() => {})\n```\nRuns every render ‚ùå"
    },

    "task": {
      "type": "coding-task",
      "title": "‚è±Ô∏è Timer App",
      "description": "Show seconds passed since page load.",
      "requirements": [
        "Use useState",
        "Use useEffect",
        "Increase seconds every 1 second"
      ],
      "starterCode": "import { useState, useEffect } from 'react';\n\nfunction Timer() {\n  return <div />;\n}\n\nexport default Timer;",
      "solution": "import { useState, useEffect } from 'react';\n\nfunction Timer() {\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setSeconds(s => s + 1);\n    }, 1000);\n\n    return () => clearInterval(id);\n  }, []);\n\n  return <p>Seconds: {seconds}</p>;\n}\n\nexport default Timer;"
    },

    "cleanup": {
      "type": "markdown",
      "title": "Cleanup Function",
      "content": "Effects can clean up.\n\nUsed for:\n‚Ä¢ Timers\n‚Ä¢ Event listeners\n‚Ä¢ Subscriptions\n\n```js\nreturn () => cleanup()\n```"
    },

    "memory": {
      "type": "memory-game",
      "title": "Effect Match",
      "pairs": [
        { "concept": "useEffect", "code": "After render" },
        { "concept": "[]", "code": "Run once" },
        { "concept": "[state]", "code": "Run on change" },
        { "concept": "cleanup", "code": "Prevent memory leak" }
      ]
    },

    "tower": {
      "type": "tower-defense",
      "concepts": [
        {
          "question": "When does useEffect run?",
          "options": [
            "Before render",
            "After render",
            "During JSX",
            "Before state"
          ],
          "correct": 1
        },
        {
          "question": "Which dependency runs once?",
          "options": ["[count]", "[]", "{}", "null"],
          "correct": 1
        }
      ],
      "waves": 2
    }
  }
}
