{
  "id": "react-019-memoization",
  "title": "Memoization in React",
  "description": "Avoid unnecessary calculations and re-renders using memoization",
  "duration": 11,
  "difficulty": "intermediate",
  "tags": ["react", "performance", "useMemo", "useCallback"],
  "prerequisites": ["react-018-usereducer"],
  "unlocks": ["react-020-react-memo"],
  "xp": 120,

  "steps": {
    "intro": {
      "type": "game-intro",
      "title": "Stop Repeating Work",
      "story": "Your app keeps doing the same heavy work again and again.",
      "preview": "Learn how React remembers results to save effort."
    },

    "refresher": {
      "type": "markdown",
      "title": "Real-Life Example",
      "content": "# Math Exam\n\nYou solve a hard problem once\n\nYou remember the answer\n\nNext time ➜ no need to solve again\n\n---\n\nThat memory is **memoization**."
    },

    "concept": {
      "type": "markdown",
      "title": "What is Memoization?",
      "content": "Memoization means:\n\n- Save the result\n- Reuse it later\n- Skip unnecessary work\n\nReact uses memoization to improve **performance**."
    },

    "concept2": {
      "type": "markdown",
      "title": "When Do We Need It?",
      "content": "Use memoization when:\n\n- Calculations are expensive\n- Components re-render often\n- Performance becomes slow"
    },

    "syntax": {
      "type": "markdown",
      "title": "useMemo Syntax",
      "content": "```\nconst value = useMemo(() => compute(), [dependencies]);\n```"
    },

    "positive": {
      "type": "interactive-code",
      "title": "Problem: Heavy Calculation",
      "description": "Calculation runs on every render.",
      "code": "import { useState } from 'react';\n\nfunction slowCalculation(num) {\n  console.log('Calculating...');\n  let result = 0;\n  for (let i = 0; i < 100000000; i++) {\n    result += num;\n  }\n  return result;\n}\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n\n  const value = slowCalculation(count);\n\n  return (\n    <div>\n      <p>{value}</p>\n      <button onClick={() => setCount(count + 1)}>+</button>\n      <input onChange={(e) => setText(e.target.value)} />\n    </div>\n  );\n}\n\nexport default App;",
      "showPreview": true,
      "explanation": "Calculation runs even when typing."
    },

    "positive2": {
      "type": "interactive-code",
      "title": "Solution: useMemo",
      "description": "Calculation runs only when needed.",
      "code": "import { useState, useMemo } from 'react';\n\nfunction slowCalculation(num) {\n  console.log('Calculating...');\n  let result = 0;\n  for (let i = 0; i < 100000000; i++) {\n    result += num;\n  }\n  return result;\n}\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n\n  const value = useMemo(() => slowCalculation(count), [count]);\n\n  return (\n    <div>\n      <p>{value}</p>\n      <button onClick={() => setCount(count + 1)}>+</button>\n      <input onChange={(e) => setText(e.target.value)} />\n    </div>\n  );\n}\n\nexport default App;",
      "showPreview": true,
      "explanation": "Calculation runs only when count changes."
    },

    "concept3": {
      "type": "markdown",
      "title": "useCallback",
      "content": "useCallback memoizes **functions**.\n\n```\nconst fn = useCallback(() => {}, []);\n```\n\nUseful when passing functions as props."
    },

    "negative": {
      "type": "debug-quiz",
      "title": "Memoization Misuse",
      "description": "useMemo used everywhere.",
      "code": "const value = useMemo(() => count + 1, [count]);",
      "question": "What is the issue?",
      "options": [
        {
          "id": "a",
          "text": "Over-optimization",
          "isCorrect": true,
          "explanation": "Simple calculations don’t need memoization."
        },
        {
          "id": "b",
          "text": "Wrong dependency",
          "isCorrect": false,
          "explanation": "Dependency is correct."
        }
      ],
      "lesson": "Use memoization only when needed."
    },

    "task": {
      "type": "coding-task",
      "title": "Memoized Total",
      "description": "Calculate total price efficiently.",
      "requirements": [
        "useMemo",
        "recalculate only when items change"
      ],
      "starterCode": "function Cart({ items }) {\n  return null;\n}\n\nexport default Cart;",
      "solution": "import { useMemo } from 'react';\n\nfunction Cart({ items }) {\n  const total = useMemo(() => {\n    return items.reduce((sum, item) => sum + item.price, 0);\n  }, [items]);\n\n  return <p>Total: {total}</p>;\n}\n\nexport default Cart;"
    },

    "challenge": {
      "type": "coding-challenge",
      "title": "Optimized Button",
      "description": "Prevent function recreation.",
      "requirements": [
        "useCallback",
        "button click handler"
      ],
      "solution": "import { useCallback } from 'react';\n\nfunction Button() {\n  const handleClick = useCallback(() => {\n    console.log('Clicked');\n  }, []);\n\n  return <button onClick={handleClick}>Click</button>;\n}\n\nexport default Button;"
    },

    "memory": {
      "type": "memory-game",
      "title": "Memoization Memory",
      "content": "Remember when to use useMemo and useCallback."
    },

    "tower": {
      "type": "tower-defense",
      "concepts": [
        {
          "question": "useMemo is used for?",
          "options": ["styling", "memoizing value", "routing", "fetching"],
          "correct": 1
        },
        {
          "question": "useCallback memoizes?",
          "options": ["state", "JSX", "function", "component"],
          "correct": 2
        }
      ],
      "waves": 3
    }
  }
}
