{
  "id": "react-012-testing",
  "title": "Testing React Components",
  "description": "Learn how to test React components with Jest and React Testing Library",
  "duration": 12,
  "difficulty": "advanced",
  "tags": ["testing", "jest", "rtl", "unit-tests", "integration-tests"],
  "prerequisites": ["react-011-performance"],
  "unlocks": ["react-013-portals"],
  "xp": 100,
   "preview": {
    "videoUrl": "/public/input.mp4", 
    "platform": "direct",
    "thumbnail": "/thumbnails/custom-hooks.jpg",
    "duration": "10:15"
  },
  "steps": {
    "refresher": {
      "type": "markdown",
      "title": "üè• Real-Life Story: Hospital Dashboard Bugs",
      "content": "# ‚ö†Ô∏è Why Testing Matters\n\nImagine a hospital app with multiple wards and hundreds of patients:\n\n- A doctor updates a patient's status incorrectly\n- Nurses see wrong information\n- A bug prevents patient discharge\n\n‚ùå Problem: Without tests, these bugs can go unnoticed until production.\n\n---\n\n## üß† Why This Happens\n\n- React components are dynamic and interactive\n- State and props change frequently\n- Complex components can easily break\n\n---\n\n## ‚úÖ React Solution: Jest + React Testing Library\n\n- **Jest**: test runner, assertions, mocks\n- **React Testing Library**: tests React components by interacting with them as a user would\n\nThink of it as a **hospital QA team**: make sure all workflows work correctly before doctors and nurses use the app."
    },
    "positive": {
      "type": "interactive-code",
      "title": "‚úÖ Positive Case: Test Patient Component",
      "description": "Write a simple unit test for a Patient component.",
      "code": "// Patient.js\nexport default function Patient({ name, status }) {\n  return <div>{name} - {status}</div>;\n}\n\n// Patient.test.js\nimport { render, screen } from '@testing-library/react';\nimport Patient from './Patient';\n\ntest('renders patient name and status', () => {\n  render(<Patient name='Meena' status='Stable' />);\n  expect(screen.getByText('Meena - Stable')).toBeInTheDocument();\n});",
      "showPreview": false,
      "explanation": "**How it works:**\n\n1. `render()` mounts the component in a virtual DOM\n2. `screen.getByText()` queries for text like a user would see\n3. `expect(...).toBeInTheDocument()` asserts that element exists\n\n‚úÖ **Key Rule:** Test what the user sees and interacts with, not implementation details."
    },
    "negative": {
      "type": "debug-quiz",
      "title": "üêõ Common Mistake: Testing Internal State",
      "description": "Why is testing `component.state` or internal variables directly discouraged in React Testing Library?",
      "code": "// Wrong approach\nexpect(patientComponent.state.patients.length).toBe(2);",
      "question": "What's wrong with this approach?",
      "options": [
        {
          "id": "a",
          "text": "It's fine, React Testing Library allows it",
          "isCorrect": false,
          "explanation": "React Testing Library encourages testing behavior, not internal implementation."
        },
        {
          "id": "b",
          "text": "Tests become fragile and break with implementation changes",
          "isCorrect": true,
          "explanation": "‚úÖ Correct! Test user-visible behavior, not internal state."
        },
        {
          "id": "c",
          "text": "Cannot access state in functional components",
          "isCorrect": false,
          "explanation": "You can‚Äôt easily access state in functional components without exposing it; that‚Äôs why behavior-based testing is preferred."
        },
        {
          "id": "d",
          "text": "screen.getByText() is faster",
          "isCorrect": false,
          "explanation": "Speed is secondary; main concern is maintainable tests."
        }
      ],
      "correctCode": "Test rendered output or user interaction rather than internal state."
    },
    "task": {
      "type": "coding-task",
      "title": "üõ†Ô∏è Your Turn: Test Hospital Components",
      "description": "Write unit tests for PatientList and PatientDashboard components.",
      "requirements": [
        "PatientList renders all patients correctly",
        "Clicking 'Critical' button updates the status",
        "PatientDashboard shows patient info",
        "Use React Testing Library queries (getByText, getByRole)"
      ],
      "starterCode": "import { render, screen } from '@testing-library/react';\nimport PatientList from './PatientList';\n\ndescribe('PatientList Tests', () => {\n  test('renders TODO', () => {\n    // TODO\n  });\n});",
      "solution": "/* Render PatientList with test data, simulate clicks with fireEvent, check updates with screen.getByText */",
      "hints": [
        "Use fireEvent.click() to simulate button clicks",
        "Use screen.getByText or getByRole to query elements",
        "Wrap components in providers if using Context or Router"
      ],
      "tests": [
        "All patients are displayed",
        "Status updates correctly on button click",
        "PatientDashboard displays correct patient info",
        "Tests pass without errors"
      ]
    },
    "challenge": {
      "type": "coding-challenge",
      "title": "üèÜ Challenge: Full Hospital Workflow Tests",
      "description": "Test a multi-ward hospital app with navigation, protected routes, and patient management.",
      "requirements": [
        "Test navigation between wards and patients",
        "Test protected routes block unauthorized users",
        "Test admit, update, and discharge actions",
        "Ensure tests are maintainable and behavior-focused"
      ],
      "starterCode": "/* Use render with Router and ProtectedRoute */",
      "solution": "/* Combine Jest + RTL to test multi-page hospital app */",
      "hints": [
        "Use MemoryRouter for routing in tests",
        "Mock user roles for ProtectedRoute",
        "Use fireEvent and screen queries to simulate user actions"
      ],
      "tests": [
        "Navigation works correctly in tests",
        "Protected routes block unauthorized roles",
        "Patient actions update UI correctly",
        "No direct state testing, only behavior assertions"
      ]
    }
  }
}
